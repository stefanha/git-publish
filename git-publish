#!/usr/bin/env python2
#
# git-publish - Prepare and store patch revisions as git tags
#
# Copyright 2011 IBM, Corp.
# Copyright 2014 Red Hat, Inc.
#
# Authors:
#   Stefan Hajnoczi <stefanha@gmail.com>
#
# This work is licensed under the MIT License.  Please see the LICENSE file or
# http://opensource.org/licenses/MIT.

import os
import glob
import sys
import optparse
import re
import tempfile
import shutil
import subprocess
import signal
from email import message_from_file, header

VERSION = '1.2+'
DEBUG = False

tag_version_re = re.compile(r'^[a-zA-Z0-9_/\-\.]+-v(\d+)$')

# As a git alias it is helpful to be a single file script with no external
# dependencies, so these git command-line wrappers are used instead of
# python-git.

class NoCurrentBranchError(Exception):
    pass

class GitSendEmailError(Exception):
    pass

class GitError(Exception):
    pass

class GitHookError(Exception):
    pass

class InspectEmailsError(Exception):
    pass

def _git_check(*args):
    '''Run a git command and return a list of lines, may raise GitError'''
    if DEBUG:
        print 'git ' + ' '.join(('"%s"' % arg if ' ' in arg else arg) for arg in args)
    cmd = subprocess.Popen(['git'] + list(args), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (out, err) = cmd.communicate()
    lines = out.split(os.linesep)[:-1]
    if cmd.returncode != 0:
        raise GitError(err)
    return lines

def _git(*args):
    '''Run a git command and return a list of lines, ignore errors'''
    try:
        return _git_check(*args)
    except GitError:
        # ignore git command errors
        return []

def _git_with_stderr(*args):
    '''Run a git command and return a list of lines for stdout and stderr'''
    if DEBUG:
        print 'git ' + ' '.join(args)
    cmd = subprocess.Popen(['git'] + list(args), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = cmd.communicate()
    return stdout.split(os.linesep)[:-1], stderr.split(os.linesep)[:-1]

def bool_from_str(s):
    '''Parse a boolean string value like true/false, yes/no, or on/off'''
    return s.lower() in ('true', 'yes', 'on')

def git_get_config(*components):
    '''Get a git-config(1) variable'''
    lines = _git('config', '.'.join(components))
    if len(lines):
        return lines[0]
    return None

def git_get_config_list(*components):
    '''Get a git-config(1) list variable'''
    return _git('config', '--get-all', '.'.join(components))

def git_unset_config(*components):
    _git('config', '--unset-all', '.'.join(components))

def git_set_config(*components):
    '''Set a git-config(1) variable'''
    if len(components) < 2:
        raise TypeError('git_set_config() takes at least 2 arguments (%d given)' % len(components))

    val = components[-1]
    name = '.'.join(components[:-1])

    if hasattr(val, '__iter__'):
        git_unset_config(name)
        for v in val:
            _git('config', '--add', name, v)
    else:
        _git('config', name, val)

def git_get_var(name):
    '''Get a git-var(1)'''
    lines = _git('var', name)
    if len(lines):
        return lines[0]
    return None

def git_get_current_branch():
    return _git_check('symbolic-ref', '--short', 'HEAD')[0]

def git_get_toplevel_dir():
    return _git('rev-parse', '--show-toplevel')[0]

def git_get_git_dir():
    return _git('rev-parse', '--git-dir')[0]

def git_delete_tag(name):
    # Hide stderr when tag does not exist
    _git_with_stderr('tag', '-d', name)

def git_get_tags(pattern=None):
    if pattern:
        return _git('tag', '-l', pattern)
    else:
        return _git('tag')

def git_get_tag_message(tag):
    message = []
    # Hide stderr when tag does not exist
    for line in _git_with_stderr('show', '--raw', '--no-color',
                                 '--pretty=medium', tag)[0][4:]:
        if line.startswith('commit '):
            message.pop()
            return message
        message.append(line)
    return None

def git_request_pull(base, remote, signed_tag):
    return _git_check('request-pull', base, remote, signed_tag)

def git_log(revlist):
    return _git('log', '--no-color', '--oneline', revlist)

def git_tag(name, annotate=None, force=False, sign=False):
    args = ['tag', '-a']
    if annotate:
        args += ['-F', annotate]
    else:
        args += ['-m', '']
    if force:
        args += ['-f']
    if sign:
        args += ['-s']
    args += [name]
    _git_check(*args)

def git_format_patch(revlist, subject_prefix=None, output_directory=None,
                     numbered=False, cover_letter=False, signoff=False):
    args = ['format-patch']
    if subject_prefix:
        args += ['--subject-prefix', subject_prefix]
    if output_directory:
        args += ['--output-directory', output_directory]
    if numbered:
        args += ['--numbered']
    if cover_letter:
        args += ['--cover-letter']
    else:
        args += ['--no-cover-letter']
    if signoff:
        args += ['--signoff']
    args += [revlist]
    _git_check(*args)

def git_send_email(to_list, cc_list, revlist_or_path, suppress_cc, in_reply_to, dry_run=False):
    args = ['git', 'send-email']
    for address in to_list:
        args += ['--to', address]
    for address in cc_list:
        args += ['--cc', address]
    if suppress_cc:
        args += ['--suppress-cc', suppress_cc]
    if in_reply_to:
        args += ['--in-reply-to', in_reply_to]
    if dry_run:
        args += ['--dry-run']
    else:
        args += ['--quiet']
    args += ['--confirm=never']
    args += [revlist_or_path]
    if dry_run:
            return _git_with_stderr(*args[1:])[0]
    else:
        if subprocess.call(args) != 0:
            raise GitSendEmailError

def invoke_hook(name, *args):
    '''Run a githooks(5) script'''
    hooks_path = git_get_config("core", "hooksPath") or \
                    os.path.join(git_get_git_dir(), 'hooks')
    hook_path = os.path.join(hooks_path, name)
    if not os.access(hook_path, os.X_OK):
        return
    if subprocess.call((hook_path,) + args, cwd=git_get_toplevel_dir()) != 0:
        raise GitHookError

def git_push(remote, ref, force=False):
    args = ['push']
    if force:
        args += ['-f']
    args += [remote, ref]
    _git_check(*args)

def git_config_with_profile(*args):
    '''Like git-config(1) except with .gitpublish added to the file lookup chain

    Note that only git-config(1) read operations are supported.  Write
    operations are not allowed since we should not modify .gitpublish.'''
    cmd = subprocess.Popen(['git', 'config', '--includes', '--file', '/dev/stdin'] + list(args),
                           stdin=subprocess.PIPE,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE)
    stdout, _ = cmd.communicate(input='''
[include]
    path = %(gitpublish)s
    path = %(gitconfig)s
    path = ~/.gitconfig
''' % dict(gitpublish=os.path.join(git_get_toplevel_dir(), '.gitpublish'),
           gitconfig=os.environ.get('GIT_CONFIG', os.path.join(git_get_git_dir(), 'config'))))
    return stdout.split(os.linesep)[:-1]

def check_profile_exists(profile_name):
    '''Return True if the profile exists, False otherwise'''
    lines = git_config_with_profile('--get-regexp', '^gitpublishprofile\\.%s\\.' % profile_name)
    return bool(lines)

def get_first_profile():
    '''Return name of the first profile, None if no profile is found'''
    lines = git_config_with_profile('--get-regexp', '^gitpublishprofile\\.*\\.')
    if len(lines):
        return lines[0].split(".")[1]
    return None

def get_profile_var(profile_name, var_name):
    '''Get a profile variable'''
    option = '.'.join(['gitpublishprofile', profile_name, var_name])
    lines = git_config_with_profile(option)
    if len(lines):
        return lines[0]
    return None

def get_profile_var_list(profile_name, var_name):
    '''Get a profile list variable'''
    option = '.'.join(['gitpublishprofile', profile_name, var_name])
    return git_config_with_profile('--get-all', option)

def setup():
    '''Add git alias in ~/.gitconfig'''
    path = os.path.abspath(sys.argv[0])
    ret = subprocess.call(['git', 'config', '--global',
                           'alias.publish', '!' + path])
    if ret == 0:
        print 'You can now use \'git publish\' like a built-in git command.'

def tag_name(topic, number):
    '''Build a tag name from a topic name and version number'''
    return '%s-v%d' % (topic, number)

def tag_name_staging(topic):
    '''Build a staging tag name from a topic name'''
    return '%s-staging' % topic

def tag_name_pull_request(topic):
    '''Build a pull request tag name from a topic name'''
    return '%s-pull-request' % topic

def get_latest_tag_number(branch):
    '''Find the latest tag number or 0 if no tags exist'''
    number = 0
    for tag in git_get_tags('%s-v[0-9]*' % branch):
        m = tag_version_re.match(tag)
        if not m:
            continue
        n = int(m.group(1))
        if n > number:
            number = n
    return number

def get_latest_tag_message(topic):
    '''Find the latest tag message or return a template if no tags exist'''
    msg = git_get_tag_message(tag_name_staging(topic))
    if msg:
        return msg

    number = get_latest_tag_number(topic)
    msg = git_get_tag_message(tag_name(topic, number))
    if msg:
        return msg

    return ['*** SUBJECT HERE ***', '', '*** BLURB HERE ***']

def get_pull_request_message(base, remote, topic):
    # Add a subject line
    message = [topic.replace('_', ' ').replace('-', ' ').capitalize() + ' patches',
               '']
    output = git_request_pull(base, remote, tag_name_pull_request(topic))

    # Chop off diffstat because git-send-email(1) will generate it
    first_separator = True
    for line in output:
        message.append(line)
        if line == '----------------------------------------------------------------':
            if not first_separator:
                break
            first_separator = False

    return message

def get_number_of_commits(base):
    return len(git_log('%s..' % base))

def edit(*filenames):
    cmd = git_get_var('GIT_EDITOR').split(" ")
    cmd.extend(filenames)
    subprocess.call(cmd)

def tag(name, template, annotate=False, force=False, sign=False):
    '''Edit a tag message and create the tag'''
    fd, tmpfile = None, None

    try:
        if annotate:
            fd, tmpfile = tempfile.mkstemp(text=True)
            os.fdopen(fd, 'w').write(os.linesep.join(template + ['']))
            edit(tmpfile)

        git_tag(name, annotate=tmpfile, force=force, sign=sign)
    finally:
        if tmpfile:
            os.unlink(tmpfile)

def menu_select(menu):
    while True:
        for k, v in menu:
            print "[%s] %s" % (k, v)
        a = raw_input()
        if a not in [k for (k, v) in menu]:
            print "Unknown command, please retry"
            continue
        return a

def parse_header(hdr):
    try:
        r = ''
        for h, c in header.decode_header(hdr):
            r += unicode(h, c) if c else h
        if '\n' in r:
            r = " ".join([x.strip() for x in r.splitlines()])
        return r
    except:
        sys.stderr.write("Failed to parse email header: %s\n", hdr)
        return hdr

def edit_email_list(cc_list):
    tmpfile = tempfile.NamedTemporaryFile(suffix='.txt')
    tmpfile.write(os.linesep.join(cc_list))
    tmpfile.flush()
    edit(tmpfile.name)
    r = []
    for line in open(tmpfile.name, "r").readlines():
        r += [x.strip() for x in line.split(",")]
    return r

def git_save_email_lists(topic, to, cc, override_cc):
    # Store --to and --cc for next revision
    git_set_config('branch', topic, 'gitpublishto', to)
    if not override_cc:
        git_set_config('branch', topic, 'gitpublishcc', cc)

def inspect_menu(tmpdir, to_list, cc_list, suppress_cc, in_reply_to,
                 topic, override_cc):
    while True:
        print 'Stopping so you can inspect the patch emails:'
        print '  cd %s' % tmpdir
        print
        output = git_send_email(to_list, cc_list, tmpdir, suppress_cc, in_reply_to, dry_run=True)
        index = 0
        files = os.listdir(tmpdir)
        files.sort()
        for f in files:
            tf = open(os.path.join(tmpdir, f), 'rb')
            m = message_from_file(tf)
            print parse_header(m['subject'])
            # Print relevant 'Adding cc' lines from the git-send-email --dry-run output
            while index < len(output) and len(output[index]):
                if output[index].find('Adding cc') != -1:
                    print '  ' + output[index]
                index += 1
            index += 1
        print
        print "To:", "\n    ".join(to_list)
        if cc_list:
            print "Cc:", "\n    ".join(cc_list)
        if in_reply_to:
            print "In-Reply-To:", in_reply_to
        print
        a = menu_select([
                ('c', 'Edit Cc list in editor (save after edit)'),
                ('t', 'Edit To list in editor (save after edit)'),
                ('p', 'Print final email headers (dry run)'),
                ('a', 'Send all'),
                ('q', 'Cancel (quit)'),
            ])
        if a == 'q':
            raise InspectEmailsError
        elif a == 'c':
            new_cc_list = edit_email_list(cc_list)
            cc_list.clear()
            cc_list.update(new_cc_list)
            git_save_email_lists(topic, to_list, cc_list, override_cc)
        elif a == 't':
            new_to_list = edit_email_list(to_list)
            to_list.clear()
            to_list.update(new_to_list)
            git_save_email_lists(topic, to_list, cc_list, override_cc)
        elif a == 'p':
            print '\n'.join(output)
        elif a == 'a':
            break

def parse_args():

    parser = optparse.OptionParser(version='%%prog %s' % VERSION,
            description='Prepare and store patch revisions as git tags.',
            epilog='Please report bugs to Stefan Hajnoczi <stefanha@gmail.com>.')
    parser.add_option('--annotate', dest='annotate', action='store_true',
                      default=False, help='review and edit each patch email')
    parser.add_option('-b', '--base', dest='base', default=None,
                      help='branch which this is based off [defaults to master]')
    parser.add_option('--cc', dest='cc', action='append', default=[],
                      help='specify a Cc: email recipient')
    parser.add_option('--cc-cmd',
                      help='specify a command to add whose output to the cc list')
    parser.add_option('--edit', dest='edit', action='store_true',
                      default=False, help='edit message but do not tag a new version')
    parser.add_option('--no-inspect-emails', dest='inspect_emails',
                      action='store_false',
                      help='no confirmation before sending emails')
    parser.add_option('--inspect-emails', dest='inspect_emails',
                      action='store_true', default=True,
                      help='show confirmation before sending emails')
    parser.add_option('-n', '--number', type='int', dest='number', default=-1,
                      help='version number [auto-generated by default]')
    parser.add_option('--no-message', '--no-cover-letter', dest='message',
                      action='store_false', help='do not add a message')
    parser.add_option('-m', '--message', '--cover-letter', dest='message',
                      action='store_true', help='add a message')
    parser.add_option('--profile', '-p', dest='profile_name', default='default',
                      help='select default settings profile')
    parser.add_option('--pull-request', dest='pull_request', action='store_true',
                      default=False, help='tag and send as a pull request')
    parser.add_option('--subject-prefix', dest='prefix', default=None,
                      help='set the email Subject: header prefix')
    parser.add_option('--clear-subject-prefix', dest='clear_prefix',
                      action='store_true', default=False,
                      help='clear the per-branch subject prefix')
    parser.add_option('--setup', dest='setup', action='store_true', default=False,
                      help='add git alias in ~/.gitconfig')
    parser.add_option('-t', '--topic', dest='topic',
                      help='topic name [defaults to current branch name]')
    parser.add_option('--to', dest='to', action='append', default=[],
                      help='specify a primary email recipient')
    parser.add_option('-s', '--signoff', dest='signoff', action='store_true',
                      default=False,
                      help='add Signed-off-by: <self> to commits when emailing')
    parser.add_option('--suppress-cc', dest='suppress_cc',
                      help='override auto-cc when sending email (man git-send-email for details)')
    parser.add_option('--forget-cc', dest='forget_cc', action='store_true',
                      default=False, help='Forget all previous CC emails')
    parser.add_option('--override-cc', dest='override_cc', action='store_true',
                      default=False, help='Ignore any profile or saved CC emails')
    parser.add_option('--in-reply-to', "-R",
                      help='specify the in-reply-to of the cover letter (or the single patch)')

    return parser.parse_args()

def main():
    options, args = parse_args()

    # The --edit option is for editing the cover letter without publishing a
    # new revision.  Therefore it doesn't make sense to combine it with options
    # that create new revisions.
    if options.edit and any((options.annotate, options.number != -1,
                             options.setup, options.to, options.pull_request)):
        print 'The --edit option cannot be used together with other options'
        return 1

    # Keep this before any operations that call out to git(1) so that setup
    # works when the current working directory is outside a git repo.
    if options.setup:
        setup()
        return 0

    if not check_profile_exists(options.profile_name):
        if options.profile_name == 'default':
            if get_first_profile():
                print 'Using defaults when a non-default profile exists. Forgot to pass --profile ?'
        else:
            print 'Profile "%s" does not exist, please check .gitpublish or git-config(1) files' % options.profile_name
            return 1

    current_branch = git_get_current_branch()

    if options.topic:
        topic = options.topic
    else:
        topic = current_branch
        if topic == 'master':
            print 'Please use a topic branch, cannot version master branch'
            return 1

    base = options.base
    if not base:
        base = git_get_config('branch', current_branch, 'gitpublishbase')
    if not base:
        base = get_profile_var(options.profile_name, 'base')
    if not base:
        base = git_get_config('git-publish', 'base')
    if not base:
        base = 'master'

    if options.number >= 0:
        number = options.number
    elif options.pull_request:
        number = 1
    else:
        number = get_latest_tag_number(topic) + 1

    to = options.to
    if not to and not options.edit:
        to = git_get_config_list('branch', topic, 'gitpublishto')
        if not to:
            to = get_profile_var_list(options.profile_name, 'to')
    to = set(to)

    if options.forget_cc:
        git_set_config('branch', topic, 'gitpublishcc', [])

    cc = set(options.cc)
    if not options.edit and not options.override_cc:
        cc = cc.union(git_get_config_list('branch', topic, 'gitpublishcc'))
        cc = cc.union(get_profile_var_list(options.profile_name, 'cc'))

    cc_cmd = options.cc_cmd
    if not cc_cmd:
        cc_cmd = git_get_config('branch', topic, 'gitpublishcccmd') or \
                 get_profile_var(options.profile_name, 'cccmd')

    if options.pull_request:
        remote = git_get_config('branch', topic, 'pushRemote')
        if remote is None:
            remote = git_get_config('remote', 'pushDefault')
        if remote is None:
            remote = git_get_config('branch', topic, 'remote')
        if remote is None or remote == '.':
            remote = get_profile_var(options.profile_name, 'remote')
        if remote is None:
            print 'Please set git config branch.%s.pushRemote or branch.%s.remote' % topic
            return 1

    profile_message_var = get_profile_var(options.profile_name, 'message')
    if options.message is not None:
        message = options.message
    elif options.pull_request:
        message = False
    elif git_get_tag_message(tag_name_staging(topic)):
        # If there is a staged tag message, we definitely want a cover letter
        message = True
    elif profile_message_var is not None:
        message = bool_from_str(profile_message_var)
    else:
        config_cover_letter = git_get_config('format', 'coverLetter')
        if config_cover_letter is None or config_cover_letter.lower() == 'auto':
            # If there are several commits we probably want a cover letter
            message = get_number_of_commits(base) > 1
        else:
            message = bool_from_str(config_cover_letter)

    invoke_hook('pre-publish-tag', base)
    # Tag the tree
    if options.pull_request:
        tag_message = ['Pull request']
        tag(tag_name_pull_request(topic), tag_message, annotate=message, force=True, sign=True)
        git_push(remote, tag_name_pull_request(topic), force=True)
    else:
        tag_message = get_latest_tag_message(topic)
        anno = options.edit or message
        tag(tag_name_staging(topic), tag_message, annotate=anno, force=True)

    if options.clear_prefix:
        git_unset_config('branch', topic, 'gitpublishprefix')

    prefix = options.prefix
    if prefix is not None:
        git_set_config('branch', topic, 'gitpublishprefix', prefix)
    else:
        prefix = git_get_config('branch', topic, 'gitpublishprefix')
    if prefix is None:
        prefix = get_profile_var(options.profile_name, 'prefix')
    if prefix is None:
        if options.pull_request:
            prefix = 'PULL'
        else:
            prefix = git_get_config('format', 'subjectprefix') or 'PATCH'
    if number > 1:
        prefix = '%s v%d' % (prefix, number)

    if to:
        if options.pull_request:
            message = get_pull_request_message(base, remote, topic)
        else:
            message = git_get_tag_message(tag_name_staging(topic))
        suppress_cc = options.suppress_cc
        if suppress_cc is None:
            suppress_cc = get_profile_var(options.profile_name, 'suppresscc')

        if options.signoff:
            signoff = True
        else:
            signoff = get_profile_var(options.profile_name, 'signoff')

        if options.inspect_emails:
            inspect_emails = True
        else:
            inspect_emails = get_profile_var(options.profile_name, 'inspect-emails')

        try:
            tmpdir = tempfile.mkdtemp()
            numbered = get_number_of_commits(base) > 1 or message
            git_format_patch(base + '..',
                             subject_prefix=prefix,
                             output_directory=tmpdir,
                             numbered=numbered,
                             cover_letter=message,
                             signoff=signoff)
            if message:
                cover_letter_path = os.path.join(tmpdir, '0000-cover-letter.patch')
                lines = open(cover_letter_path).readlines()
                lines = [s.replace('*** SUBJECT HERE ***', message[0]) for s in lines]
                blurb = os.linesep.join(message[2:])
                lines = [s.replace('*** BLURB HERE ***', blurb) for s in lines]
                open(cover_letter_path, 'w').writelines(lines)
            patches = sorted(glob.glob(os.path.join(tmpdir, '*')))
            if options.annotate:
                edit(*patches)
            if cc_cmd:
                for x in patches:
                    output = subprocess.check_output(cc_cmd + " " + x,
                                shell=True)
                    cc = cc.union(output.splitlines())
            cc.difference_update(to)
            if inspect_emails:
                inspect_menu(tmpdir, to, cc, suppress_cc, options.in_reply_to,
                             topic, options.override_cc)

            invoke_hook('pre-publish-send-email', tmpdir)
            git_send_email(to, cc, tmpdir, suppress_cc, options.in_reply_to)
        except (GitError, GitSendEmailError, GitHookError, InspectEmailsError):
            return 1
        finally:
            if tmpdir:
                shutil.rmtree(tmpdir)

        git_save_email_lists(topic, to, cc, options.override_cc)

        if not options.pull_request:
            # Publishing is done, stablize the tag now
            _git_check('tag', '-f', tag_name(topic, number), tag_name_staging(topic))
            git_delete_tag(tag_name_staging(topic))

    return 0

if __name__ == '__main__':
    sys.exit(main())
