#!/usr/bin/env python2
#
# git-publish - Prepare and store patch revisions as git tags
#
# Copyright 2011 IBM, Corp.
# Copyright 2014 Red Hat, Inc.
#
# Authors:
#   Stefan Hajnoczi <stefanha@gmail.com>
#
# This work is licensed under the MIT License.  Please see the LICENSE file or
# http://opensource.org/licenses/MIT.

import os
import glob
import sys
import optparse
import re
import tempfile
import shutil
import subprocess
import signal
import email

VERSION = '1.0+'
DEBUG = False

tag_version_re = re.compile(r'^[a-zA-Z0-9_/\-\.]+-v(\d+)$')

# As a git alias it is helpful to be a single file script with no external
# dependencies, so these git command-line wrappers are used instead of
# python-git.

class NoCurrentBranchError(Exception):
    pass

class GitSendEmailError(Exception):
    pass

class GitHookError(Exception):
    pass

class UserCancel(Exception):
    pass

def error(*msgs):
    sys.stderr.write(*msgs)

def _git(*args):
    '''Run a git command and return a list of lines'''
    if DEBUG:
        print 'git ' + ' '.join(args)
    cmd = subprocess.Popen(['git'] + list(args), stdout=subprocess.PIPE)
    return cmd.communicate()[0].split(os.linesep)[:-1]

def _git_with_stderr(*args):
    '''Run a git command and return a list of lines for stdout and stderr'''
    if DEBUG:
        print 'git ' + ' '.join(args)
    cmd = subprocess.Popen(['git'] + list(args), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = cmd.communicate()
    return stdout.split(os.linesep)[:-1], stderr.split(os.linesep)[:-1]

def git_get_config(*components):
    '''Get a git-config(1) variable'''
    lines = _git('config', '.'.join(components))
    if len(lines):
        return lines[0]
    return None

def git_get_config_list(*components):
    '''Get a git-config(1) list variable'''
    return _git('config', '--get-all', '.'.join(components))

def git_set_config(*components):
    '''Set a git-config(1) variable'''
    if len(components) < 2:
        raise TypeError('git_set_config() takes at least 2 arguments (%d given)' % len(components))

    val = components[-1]
    name = '.'.join(components[:-1])

    if isinstance(val, list) or isinstance(val, tuple):
        _git('config', '--unset-all', name)
        for v in val:
            _git('config', '--add', name, v)
    else:
        _git('config', '.'.join(components), value)

def git_get_var(name):
    '''Get a git-var(1)'''
    lines = _git('var', name)
    if len(lines):
        return lines[0]
    return None

def git_get_current_branch():
    for line in _git('branch', '--no-color'):
        if '*' in line:
            return line.split()[1]
    raise NoCurrentBranchError

def git_get_toplevel_dir():
    return _git('rev-parse', '--show-toplevel')[0]

def git_get_git_dir():
    return _git('rev-parse', '--git-dir')[0]

def git_delete_tag(name):
    # Hide stderr when tag does not exist
    _git_with_stderr('tag', '-d', name)

def git_get_tags(pattern=None):
    if pattern:
        return _git('tag', '-l', pattern)
    else:
        return _git('tag')

def git_get_tag_message(tag):
    message = []
    # Hide stderr when tag does not exist
    for line in _git_with_stderr('show', '--raw', '--no-color',
                                 '--pretty=medium', tag)[0][4:]:
        if line.startswith('commit '):
            message.pop()
            return message
        message.append(line)
    return None

def git_request_pull(base, remote, signed_tag):
    return _git('request-pull', base, remote, signed_tag)

def git_log(revlist):
    return _git('log', '--no-color', '--oneline', revlist)

def git_tag(name, annotate=None, force=False, sign=False):
    args = ['tag', '-a']
    if annotate:
        args += ['-F', annotate]
    else:
        args += ['-m', '']
    if force:
        args += ['-f']
    if sign:
        args += ['-s']
    args += [name]
    _git(*args)

def git_format_patch(revlist, subject_prefix=None, output_directory=None,
                     numbered=False, cover_letter=False, signoff=False):
    args = ['format-patch']
    if subject_prefix:
        args += ['--subject-prefix', subject_prefix]
    if output_directory:
        args += ['--output-directory', output_directory]
    if numbered:
        args += ['--numbered']
    if cover_letter:
        args += ['--cover-letter']
    else:
        args += ['--no-cover-letter']
    if signoff:
        args += ['--signoff']
    args += [revlist]
    _git(*args)

def git_send_email(to, cc, suppress_cc, revlist_or_path):
    args = ['git', 'send-email']
    args += ['--confirm=never', '--quiet']
    args += [revlist_or_path]
    for t in to or []:
        args += ['--to', t]
    for t in cc or []:
        args += ['--cc', t]
    if suppress_cc:
        args += ['--suppress_cc', suppress_cc]
    if subprocess.call(args) != 0:
        raise GitSendEmailError

def invoke_hook(name, *args):
    '''Run a githooks(5) script'''
    hook_path = os.path.join(git_get_git_dir(), 'hooks', name)
    if not os.access(hook_path, os.X_OK):
        return
    if subprocess.call((hook_path,) + args, cwd=git_get_toplevel_dir()) != 0:
        raise GitHookError

def git_push(remote, ref, force=False):
    args = ['push']
    if force:
        args += ['-f']
    args += [remote, ref]
    _git(*args)

def git_config_with_profile(*args):
    '''Like git-config(1) except with .gitpublish added to the file lookup chain

    Note that only git-config(1) read operations are supported.  Write
    operations are not allowed since we should not modify .gitpublish.'''
    cmd = subprocess.Popen(['git', 'config', '--includes', '--file', '/dev/stdin'] + list(args),
                           stdin=subprocess.PIPE,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE)
    stdout, _ = cmd.communicate(input='''
[include]
    path = %(gitpublish)s
    path = %(gitconfig)s
    path = ~/.gitconfig
''' % dict(gitpublish=os.path.join(git_get_toplevel_dir(), '.gitpublish'),
           gitconfig=os.environ.get('GIT_CONFIG', os.path.join(git_get_git_dir(), 'config'))))
    return stdout.split(os.linesep)[:-1]

def check_profile_exists(profile_name):
    '''Return True if the profile exists, False otherwise'''
    lines = git_config_with_profile('--get-regexp', '^gitpublishprofile\\.%s\\.' % profile_name)
    return bool(lines)

def get_profile_var(profile_name, var_name):
    '''Get a profile variable'''
    option = '.'.join(['gitpublishprofile', profile_name, var_name])
    lines = git_config_with_profile(option)
    if len(lines):
        return lines[0]
    return None

def get_profile_var_list(profile_name, var_name):
    '''Get a profile list variable'''
    option = '.'.join(['gitpublishprofile', profile_name, var_name])
    return git_config_with_profile('--get-all', option)

def setup():
    '''Add git alias in ~/.gitconfig'''
    path = os.path.abspath(sys.argv[0])
    ret = subprocess.call(['git', 'config', '--global',
                           'alias.publish', '!' + path])
    if ret == 0:
        print 'You can now use \'git publish\' like a built-in git command.'

def tag_name(topic, number):
    '''Build a tag name from a topic name and version number'''
    return 'git-publish.%s-v%d' % (topic, number)

def tag_name_staging(topic):
    '''Build a staging tag name from a topic name'''
    return '%s-staging' % topic

def tag_name_pull_request(topic):
    '''Build a pull request tag name from a topic name'''
    return '%s-pull-request' % topic

def get_latest_tag_number(branch):
    '''Find the latest tag number or 0 if no tags exist'''
    number = 0
    for tag in git_get_tags('git-publish.%s-v[0-9]*' % branch):
        m = tag_version_re.match(tag)
        if not m:
            continue
        n = int(m.group(1))
        if n > number:
            number = n
    return number

def get_latest_tag_message(topic):
    '''Find the latest tag message or return a template if no tags exist'''
    msg = git_get_tag_message(tag_name_staging(topic))
    if msg:
        return msg

    number = get_latest_tag_number(topic)
    msg = git_get_tag_message(tag_name(topic, number))
    if msg:
        return msg

    return ['*** SUBJECT HERE ***', '', '*** BLURB HERE ***']

def get_pull_request_message(base, remote, topic):
    # Add a subject line
    message = [topic.replace('_', ' ').replace('-', ' ').capitalize() + ' patches',
               '']
    output = git_request_pull(base, remote, tag_name_pull_request(topic))

    # Chop off diffstat because git-send-email(1) will generate it
    first_separator = True
    for line in output:
        message.append(line)
        if line == '----------------------------------------------------------------':
            if not first_separator:
                break
            first_separator = False

    return message

def get_number_of_commits(base):
    return len(git_log('%s..' % base))

def edit(*filenames):
    cmd = [git_get_var('GIT_EDITOR')]
    cmd.extend(filenames)
    subprocess.call(cmd)

def tag(name, template, annotate=False, force=False, sign=False):
    '''Edit a tag message and create the tag'''
    fd, tmpfile = None, None

    try:
        if annotate:
            fd, tmpfile = tempfile.mkstemp(text=True)
            os.fdopen(fd, 'w').write(os.linesep.join(template + ['']))
            edit(tmpfile)

        git_tag(name, annotate=tmpfile, force=force, sign=sign)
    finally:
        if tmpfile:
            os.unlink(tmpfile)

def menu_select(menu):
    while True:
        for k, v in menu:
            print "[%s] %s" % (k, v)
        a = raw_input()
        if a not in [k for (k, v) in menu]:
            print "Unknown command, please reselect"
            continue
        return a

def remove_from_addr_list(l, pattern):
    ll = [x.strip() for x in l.split(',') if len(x.strip()) > 0]
    r = [x for x in ll if pattern not in x]
    return r.join(',')

def send_email(to_list, cc_list, prefix, base, message, annotate, signoff,
               inspect_emails, suppress_cc):
    numbered = get_number_of_commits(base) > 1
    cover_letter = bool(message)
    revlist = '%s..' % base

    try:
        tmpdir = tempfile.mkdtemp()

        git_format_patch(revlist,
                         subject_prefix=prefix,
                         output_directory=tmpdir,
                         numbered=numbered,
                         cover_letter=cover_letter,
                         signoff=signoff)

        if message:
            cover_letter_path = os.path.join(tmpdir, '0000-cover-letter.patch')
            lines = open(cover_letter_path).readlines()
            lines = [s.replace('*** SUBJECT HERE ***', message[0]) for s in lines]
            blurb = os.linesep.join(message[2:])
            lines = [s.replace('*** BLURB HERE ***', blurb) for s in lines]
            open(cover_letter_path, 'w').writelines(lines)

        if annotate:
            edit(*glob.glob(os.path.join(tmpdir, '*')))

        if inspect_emails:
            print 'Stopping so you can inspect and edit patch emails manually:'
            print
            files = os.listdir(tmpdir)
            files.sort()
            for f in files:
                tf = open(os.path.join(tmpdir, f), 'r')
                m = email.message_from_file(tf)
                print m['subject']
            print
            print "To:", "\n    ".join(to_list)
            if cc_list:
                print "Cc:", "\n    ".join(cc_list)
            print
            while True:
                a = menu_select([
                        ('s', 'Send'),
                        ('q', 'Quit (cancel)'),
                    ])
                if a == 'q':
                    raise UserCancel
                elif a == 's':
                    break
        invoke_hook('pre-publish-send-email', tmpdir)

        git_send_email(to_list, cc_list, suppress_cc, tmpdir)
    finally:
        if tmpdir:
            shutil.rmtree(tmpdir)

def main():
    parser = optparse.OptionParser(version='%%prog %s' % VERSION,
            description='Prepare and store patch revisions as git tags.',
            epilog='Please report bugs to Stefan Hajnoczi <stefanha@gmail.com>.')
    parser.add_option('--annotate', dest='annotate', action='store_true',
                      default=False, help='review and edit each patch email')
    parser.add_option('-b', '--base', dest='base', default=None,
                      help='branch which this is based off [defaults to master]')
    parser.add_option('--cc', dest='cc', action='append', default=[],
                      help='specify a Cc: email recipient')
    parser.add_option('--edit', dest='edit', action='store_true',
                      default=False, help='edit message but do not tag a new version')
    parser.add_option('-i', '--inspect-email', action='store_true', default=False,
                      help='prompt for action before sending')
    parser.add_option('-n', '--number', type='int', dest='number', default=-1,
                      help='version number [auto-generated by default]')
    parser.add_option('--no-message', '--no-cover-letter', dest='message',
                      action='store_false', help='do not add a message')
    parser.add_option('-m', '--message', '--cover-letter', dest='message',
                      action='store_true', help='add a message')
    parser.add_option('--profile', dest='profile_name', default='default',
                      help='select default settings profile')
    parser.add_option('--pull-request', dest='pull_request', action='store_true',
                      default=False, help='tag and send as a pull request')
    parser.add_option('--subject-prefix', dest='prefix', default=None,
                      help='set the email Subject: header prefix')
    parser.add_option('--setup', dest='setup', action='store_true', default=False,
                      help='add git alias in ~/.gitconfig')
    parser.add_option('-t', '--topic', dest='topic',
                      help='topic name [defaults to current branch name]')
    parser.add_option('--to', dest='to', action='append', default=[],
                      help='specify a primary email recipient')
    parser.add_option('-s', '--signoff', dest='signoff', action='store_true',
                      default=False,
                      help='add Signed-off-by: <self> to commits when emailing')
    parser.add_option('--suppress-cc', dest='suppress_cc',
                      help='override auto-cc when sending email (man git-send-email for details)')

    options, args = parser.parse_args()

    # The --edit option is for editing the cover letter without publishing a
    # new revision.  Therefore it doesn't make sense to combine it with options
    # that create new revisions.
    if options.edit and any((options.annotate, options.number != -1,
                             options.setup, options.to, options.pull_request)):
        print 'The --edit option cannot be used together with other options'
        return 1

    if options.profile_name != 'default' and not check_profile_exists(options.profile_name):
        print 'Profile "%s" does not exist, please check .gitpublish or git-config(1) files'
        return 1

    if options.setup:
        setup()
        return 0

    current_branch = git_get_current_branch()

    if options.topic:
        topic = options.topic
    else:
        topic = current_branch
        if topic == 'master':
            print 'Please use a topic branch, cannot version master branch'
            return 1

    base = options.base
    if not base:
        base = git_get_config('branch', current_branch, 'gitpublishbase')
    if not base:
        base = get_profile_var(options.profile_name, 'base')
    if not base:
        base = git_get_config('git-publish', 'base')
    if not base:
        base = 'master'

    if options.number >= 0:
        number = options.number
    elif options.pull_request:
        number = 1
    else:
        number = get_latest_tag_number(topic) + 1

    to = options.to
    if not to and not options.edit:
        to = git_get_config_list('branch', topic, 'gitpublishto')
        if not to:
            to = get_profile_var_list(options.profile_name, 'to')

    cc = options.cc
    if not cc and not options.edit:
        cc = git_get_config_list('branch', topic, 'gitpublishcc')
        if not cc:
            cc = get_profile_var_list(options.profile_name, 'cc')

    if options.pull_request:
        remote = git_get_config('branch', topic, 'remote')
        if remote is None:
            remote = get_profile_var(options.profile_name, 'remote')
        if remote is None:
            print 'Please set git config branch.%s.remote' % topic
            return 1

    profile_message_var = get_profile_var(options.profile_name, 'message')
    if options.message is not None:
        message = options.message
    elif options.pull_request:
        message = False
    elif git_get_tags(tag_name_staging(topic)):
        # If there is a staged tag message, we definitely want a cover letter
        message = True
    elif profile_message_var is not None:
        message = profile_message_var == 'true'
    else:
        config_cover_letter = git_get_config('format', 'coverLetter')
        if config_cover_letter == 'true':
            message = True
        elif config_cover_letter == 'false':
            message = False
        else: # treat as 'auto'
            # If there are several commits we probably want a cover letter
            message = get_number_of_commits(base) > 1

    # Tag the tree
    if options.pull_request:
        tag_message = ['Pull request']
        tag(tag_name_pull_request(topic), tag_message, annotate=message, force=True, sign=True)
        git_push(remote, tag_name_pull_request(topic), force=True)
    else:
        tag_message = get_latest_tag_message(topic)
        if options.edit or message:
            tag(tag_name_staging(topic), tag_message, annotate=True, force=True)

    prefix = options.prefix
    if prefix is None:
        prefix = get_profile_var(options.profile_name, 'prefix')
    if prefix is None:
        if options.pull_request:
            prefix = 'PULL'
        else:
            prefix = 'PATCH'
    if number > 1:
        prefix = '%s v%d' % (prefix, number)

    if not to:
        error('Send to whom? (Use --to or configure with "to =" in profile)\n')
        return 1

    if options.pull_request:
        message = get_pull_request_message(base, remote, topic)
    else:
        message = git_get_tag_message(tag_name_staging(topic))

    suppress_cc = options.suppress_cc
    if suppress_cc is None:
        suppress_cc = get_profile_var(options.profile_name, 'suppresscc')

    try:
        send_email(to, cc, prefix, base, message,
                   options.annotate, options.signoff,
                   options.inspect_emails, suppress_cc)
        tag(tag_name(topic, number), tag_name_staging(topic))
    except (GitSendEmailError, GitHookError, UserCancel):
        return 1

    # Store --to and --cc for next revision
    git_set_config('branch', topic, 'gitpublishto', to)
    git_set_config('branch', topic, 'gitpublishcc', cc)

    return 0

if __name__ == '__main__':
    sys.exit(main())
